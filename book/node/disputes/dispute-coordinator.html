<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dispute Coordinator - The Polkadot Parachain Host Implementers&#x27; Guide</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Preamble</a></li><li class="chapter-item expanded "><a href="../../whence-parachains.html"><strong aria-hidden="true">1.</strong> Whence Parachains</a></li><li class="chapter-item expanded "><a href="../../protocol-overview.html"><strong aria-hidden="true">2.</strong> Protocol Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../protocol-approval.html"><strong aria-hidden="true">2.1.</strong> Approval Process</a></li><li class="chapter-item expanded "><a href="../../protocol-disputes.html"><strong aria-hidden="true">2.2.</strong> Disputes Process</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../disputes-flow.html"><strong aria-hidden="true">2.2.1.</strong> Dispute Flow</a></li></ol></li><li class="chapter-item expanded "><a href="../../protocol-chain-selection.html"><strong aria-hidden="true">2.3.</strong> Chain Selection and Finalization</a></li></ol></li><li class="chapter-item expanded "><a href="../../architecture.html"><strong aria-hidden="true">3.</strong> Architecture Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../messaging.html"><strong aria-hidden="true">3.1.</strong> Messaging Overview</a></li><li class="chapter-item expanded "><a href="../../pvf-prechecking.html"><strong aria-hidden="true">3.2.</strong> PVF Pre-checking</a></li></ol></li><li class="chapter-item expanded "><a href="../../runtime/index.html"><strong aria-hidden="true">4.</strong> Runtime Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../runtime/initializer.html"><strong aria-hidden="true">4.1.</strong> Initializer Module</a></li><li class="chapter-item expanded "><a href="../../runtime/configuration.html"><strong aria-hidden="true">4.2.</strong> Configuration Module</a></li><li class="chapter-item expanded "><a href="../../runtime/shared.html"><strong aria-hidden="true">4.3.</strong> Shared</a></li><li class="chapter-item expanded "><a href="../../runtime/disputes.html"><strong aria-hidden="true">4.4.</strong> Disputes Module</a></li><li class="chapter-item expanded "><a href="../../runtime/paras.html"><strong aria-hidden="true">4.5.</strong> Paras Module</a></li><li class="chapter-item expanded "><a href="../../runtime/scheduler.html"><strong aria-hidden="true">4.6.</strong> Scheduler Module</a></li><li class="chapter-item expanded "><a href="../../runtime/inclusion.html"><strong aria-hidden="true">4.7.</strong> Inclusion Module</a></li><li class="chapter-item expanded "><a href="../../runtime/parainherent.html"><strong aria-hidden="true">4.8.</strong> ParaInherent Module</a></li><li class="chapter-item expanded "><a href="../../runtime/dmp.html"><strong aria-hidden="true">4.9.</strong> DMP Module</a></li><li class="chapter-item expanded "><a href="../../runtime/ump.html"><strong aria-hidden="true">4.10.</strong> UMP Module</a></li><li class="chapter-item expanded "><a href="../../runtime/hrmp.html"><strong aria-hidden="true">4.11.</strong> HRMP Module</a></li><li class="chapter-item expanded "><a href="../../runtime/session_info.html"><strong aria-hidden="true">4.12.</strong> Session Info Module</a></li></ol></li><li class="chapter-item expanded "><a href="../../runtime-api/index.html"><strong aria-hidden="true">5.</strong> Runtime APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../runtime-api/validators.html"><strong aria-hidden="true">5.1.</strong> Validators</a></li><li class="chapter-item expanded "><a href="../../runtime-api/validator-groups.html"><strong aria-hidden="true">5.2.</strong> Validator Groups</a></li><li class="chapter-item expanded "><a href="../../runtime-api/availability-cores.html"><strong aria-hidden="true">5.3.</strong> Availability Cores</a></li><li class="chapter-item expanded "><a href="../../runtime-api/persisted-validation-data.html"><strong aria-hidden="true">5.4.</strong> Persisted Validation Data</a></li><li class="chapter-item expanded "><a href="../../runtime-api/session-index.html"><strong aria-hidden="true">5.5.</strong> Session Index</a></li><li class="chapter-item expanded "><a href="../../runtime-api/validation-code.html"><strong aria-hidden="true">5.6.</strong> Validation Code</a></li><li class="chapter-item expanded "><a href="../../runtime-api/candidate-pending-availability.html"><strong aria-hidden="true">5.7.</strong> Candidate Pending Availability</a></li><li class="chapter-item expanded "><a href="../../runtime-api/candidate-events.html"><strong aria-hidden="true">5.8.</strong> Candidate Events</a></li><li class="chapter-item expanded "><a href="../../runtime-api/disputes-info.html"><strong aria-hidden="true">5.9.</strong> Disputes Info</a></li><li class="chapter-item expanded "><a href="../../runtime-api/candidates-included.html"><strong aria-hidden="true">5.10.</strong> Candidates Included</a></li><li class="chapter-item expanded "><a href="../../runtime-api/pvf-prechecking.html"><strong aria-hidden="true">5.11.</strong> PVF Pre-checking</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/index.html"><strong aria-hidden="true">6.</strong> Node Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/subsystems-and-jobs.html"><strong aria-hidden="true">6.1.</strong> Subsystems and Jobs</a></li><li class="chapter-item expanded "><a href="../../node/overseer.html"><strong aria-hidden="true">6.2.</strong> Overseer</a></li><li class="chapter-item expanded "><a href="../../node/grandpa-voting-rule.html"><strong aria-hidden="true">6.3.</strong> GRANDPA Voting Rule</a></li><li class="chapter-item expanded "><a href="../../node/collators/index.html"><strong aria-hidden="true">6.4.</strong> Collator Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/collators/collation-generation.html"><strong aria-hidden="true">6.4.1.</strong> Collation Generation</a></li><li class="chapter-item expanded "><a href="../../node/collators/collator-protocol.html"><strong aria-hidden="true">6.4.2.</strong> Collator Protocol</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/backing/index.html"><strong aria-hidden="true">6.5.</strong> Backing Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/backing/candidate-backing.html"><strong aria-hidden="true">6.5.1.</strong> Candidate Backing</a></li><li class="chapter-item expanded "><a href="../../node/backing/statement-distribution.html"><strong aria-hidden="true">6.5.2.</strong> Statement Distribution</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/availability/index.html"><strong aria-hidden="true">6.6.</strong> Availability Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/availability/availability-distribution.html"><strong aria-hidden="true">6.6.1.</strong> Availability Distribution</a></li><li class="chapter-item expanded "><a href="../../node/availability/availability-recovery.html"><strong aria-hidden="true">6.6.2.</strong> Availability Recovery</a></li><li class="chapter-item expanded "><a href="../../node/availability/bitfield-distribution.html"><strong aria-hidden="true">6.6.3.</strong> Bitfield Distribution</a></li><li class="chapter-item expanded "><a href="../../node/availability/bitfield-signing.html"><strong aria-hidden="true">6.6.4.</strong> Bitfield Signing</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/approval/index.html"><strong aria-hidden="true">6.7.</strong> Approval Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/approval/approval-voting.html"><strong aria-hidden="true">6.7.1.</strong> Approval Voting</a></li><li class="chapter-item expanded "><a href="../../node/approval/approval-distribution.html"><strong aria-hidden="true">6.7.2.</strong> Approval Distribution</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/disputes/index.html"><strong aria-hidden="true">6.8.</strong> Disputes Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/disputes/dispute-coordinator.html" class="active"><strong aria-hidden="true">6.8.1.</strong> Dispute Coordinator</a></li><li class="chapter-item expanded "><a href="../../node/disputes/dispute-distribution.html"><strong aria-hidden="true">6.8.2.</strong> Dispute Distribution</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/utility/index.html"><strong aria-hidden="true">6.9.</strong> Utility Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/utility/availability-store.html"><strong aria-hidden="true">6.9.1.</strong> Availability Store</a></li><li class="chapter-item expanded "><a href="../../node/utility/candidate-validation.html"><strong aria-hidden="true">6.9.2.</strong> Candidate Validation</a></li><li class="chapter-item expanded "><a href="../../node/utility/provisioner.html"><strong aria-hidden="true">6.9.3.</strong> Provisioner</a></li><li class="chapter-item expanded "><a href="../../node/utility/network-bridge.html"><strong aria-hidden="true">6.9.4.</strong> Network Bridge</a></li><li class="chapter-item expanded "><a href="../../node/utility/gossip-support.html"><strong aria-hidden="true">6.9.5.</strong> Gossip Support</a></li><li class="chapter-item expanded "><a href="../../node/utility/misbehavior-arbitration.html"><strong aria-hidden="true">6.9.6.</strong> Misbehavior Arbitration</a></li><li class="chapter-item expanded "><a href="../../node/utility/peer-set-manager.html"><strong aria-hidden="true">6.9.7.</strong> Peer Set Manager</a></li><li class="chapter-item expanded "><a href="../../node/utility/runtime-api.html"><strong aria-hidden="true">6.9.8.</strong> Runtime API Requests</a></li><li class="chapter-item expanded "><a href="../../node/utility/chain-api.html"><strong aria-hidden="true">6.9.9.</strong> Chain API Requests</a></li><li class="chapter-item expanded "><a href="../../node/utility/chain-selection.html"><strong aria-hidden="true">6.9.10.</strong> Chain Selection Request</a></li><li class="chapter-item expanded "><a href="../../node/utility/pvf-prechecker.html"><strong aria-hidden="true">6.9.11.</strong> PVF Pre-Checking</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../types/index.html"><strong aria-hidden="true">7.</strong> Data Structures and Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../types/candidate.html"><strong aria-hidden="true">7.1.</strong> Candidate</a></li><li class="chapter-item expanded "><a href="../../types/backing.html"><strong aria-hidden="true">7.2.</strong> Backing</a></li><li class="chapter-item expanded "><a href="../../types/availability.html"><strong aria-hidden="true">7.3.</strong> Availability</a></li><li class="chapter-item expanded "><a href="../../types/overseer-protocol.html"><strong aria-hidden="true">7.4.</strong> Overseer and Subsystem Protocol</a></li><li class="chapter-item expanded "><a href="../../types/runtime.html"><strong aria-hidden="true">7.5.</strong> Runtime</a></li><li class="chapter-item expanded "><a href="../../types/chain.html"><strong aria-hidden="true">7.6.</strong> Chain</a></li><li class="chapter-item expanded "><a href="../../types/messages.html"><strong aria-hidden="true">7.7.</strong> Messages</a></li><li class="chapter-item expanded "><a href="../../types/network.html"><strong aria-hidden="true">7.8.</strong> Network</a></li><li class="chapter-item expanded "><a href="../../types/approval.html"><strong aria-hidden="true">7.9.</strong> Approvals</a></li><li class="chapter-item expanded "><a href="../../types/disputes.html"><strong aria-hidden="true">7.10.</strong> Disputes</a></li><li class="chapter-item expanded "><a href="../../types/pvf-prechecking.html"><strong aria-hidden="true">7.11.</strong> PVF Pre-checking</a></li></ol></li><li class="chapter-item expanded "><a href="../../glossary.html">Glossary</a></li><li class="chapter-item expanded affix "><a href="../../further-reading.html">Further Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Polkadot Parachain Host Implementers&#x27; Guide</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dispute-coordinator"><a class="header" href="#dispute-coordinator">Dispute Coordinator</a></h1>
<p>The coordinator is the central subsystem of the node-side components which
participate in disputes. It wraps a database, which used to track statements
observed by <em>all</em> validators over some window of sessions. Votes older than this
session window are pruned.</p>
<p>In particular the dispute-coordinator is responsible for:</p>
<ul>
<li>Ensuring that the node is able to raise a dispute in case an invalid candidate
is found during approval checking.</li>
<li>Ensuring malicious approval votes will be recorded, so nodes can get slashed
properly.</li>
<li>Coordinating actual participation in a dispute, ensuring that the node
participates in any justified dispute in a way that ensures resolution of
disputes on the network even in the case of many disputes raised (flood/DoS
scenario).</li>
<li>Provide an API for chain selection, so we can prevent finalization of any
chain which has included candidates for which a dispute is either ongoing or
concluded invalid and avoid building on chains with an included invalid
candidate.</li>
<li>Provide an API for retrieving (resolved) disputes, including all votes, both
implicit (approval, backing) and explicit dispute votes. So validators can get
rewarded/slashed accordingly.</li>
</ul>
<h2 id="ensuring-that-disputes-can-be-raised"><a class="header" href="#ensuring-that-disputes-can-be-raised">Ensuring That Disputes Can Be Raised</a></h2>
<p>If a candidate turns out invalid in approval checking, the <code>approval-voting</code>
subsystem will try to issue a dispute. For this, it will send a message
<code>DisputeCoordinatorMessage::IssueLocalStatement</code> to the dispute coordinator,
indicating to cast an explicit invalid vote. It is the responsibility of the
dispute coordinator on reception of such a message to create and sign that
explicit invalid vote and trigger a dispute if none for that candidate is
already ongoing.</p>
<p>In order to raise a dispute, a node has to be able to provide two opposing votes.
Given that the reason of the backing phase is to have validators with skin in
the game, the opposing valid vote will very likely be a backing vote. It could
also be some already cast approval vote, but the significant point here is: As
long as we have backing votes available, any node will be able to raise a
dispute.</p>
<p>Therefore a vital responsibility of the dispute coordinator is to make sure
backing votes are available for all candidates that might still get disputed. To
accomplish this task in an efficient way the dispute-coordinator relies on chain
scraping. Whenever a candidate gets backed on chain, we record in chain storage
the backing votes imported in that block. This way, given the chain state for a
given relay chain block, we can retrieve via a provided runtime API the backing
votes imported by that block. The dispute coordinator makes sure to query those
votes for any non finalized blocks: In case of missed blocks, it will do chain
traversal as necessary.</p>
<p>Relying on chain scraping is very efficient for two reasons:</p>
<ol>
<li>Votes are already batched. We import all available backing votes for a
candidate all at once. If instead we imported votes from candidate-backing as
they came along, we would import each vote individually which is
inefficient in the current dispute coordinator implementation (quadratic
complexity).</li>
<li>We also import less votes in total, as we avoid importing statements for
candidates that never got successfully backed on any chain.</li>
</ol>
<p>It also is secure, because disputes are only ever raised in the approval voting
phase. A node only starts the approval process after it has seen a candidate
included on some chain, for that to happen it must have been backed previously.
Therefore backing votes are available at that point in time. Signals are
processed first, so even if a block is skipped and we only start importing
backing votes on the including block, we will have seen the backing votes by the
time we process messages from approval voting.</p>
<p>In summary, for making it possible for a dispute to be raised, recording of
backing votes from chain is sufficient and efficient. In particular there is no
need to preemptively import approval votes, which has shown to be a very
inefficient process. (Quadratic complexity adds up, with 35 votes in total per candidate)</p>
<p>Approval votes are very relevant nonetheless as we are going to see in the next
section.</p>
<h2 id="ensuring-malicious-approval-votes-will-be-recorded"><a class="header" href="#ensuring-malicious-approval-votes-will-be-recorded">Ensuring Malicious Approval Votes Will Be Recorded</a></h2>
<h3 id="ensuring-recording"><a class="header" href="#ensuring-recording">Ensuring Recording</a></h3>
<p>While there is no need to record approval votes in the dispute coordinator
preemptively, we do need to make sure they are recorded when a dispute
actually happens. This is because only votes recorded by the dispute
coordinator will be considered for slashing. While the backing group always gets
slashed, a serious attack attempt will likely also consist of malicious approval
checkers which will cast approval votes, although the candidate is invalid. If
we did not import those votes, those nodes would likely cast an <code>invalid</code> explicit
vote as part of the dispute in addition to their approval vote and thus avoid a
slash. With the 2/3rd honest assumption it seems unrealistic that malicious
actors will keep sending approval votes once they became aware of a raised
dispute. Hence the most crucial approval votes to import are the early ones
(tranche 0), to take into account network latencies and such we still want to
import approval votes at a later point in time as well (in particular we need to
make sure the dispute can conclude, but more on that later).</p>
<p>As mentioned already previously, importing votes is most efficient when batched.
At the same time approval voting and disputes are running concurrently so
approval votes are expected to trickle in still, when a dispute is already
ongoing.</p>
<p>Hence, we have the following requirements for importing approval votes:</p>
<ol>
<li>Only import them when there is a dispute, because otherwise we are
wasting lots of resources <em>always</em> for the exceptional case of a dispute.</li>
<li>Import votes batched when possible, to avoid quadratic import complexity.</li>
<li>Take into account that approval voting is still ongoing, while a dispute is
already running.</li>
</ol>
<p>With a design where approval voting sends votes to the dispute-coordinator by
itself, we would need to make approval voting aware of ongoing disputes and
once it is aware it could start sending all already existing votes batched and
trickling in votes as they come. The problem with this is, that it adds some
unnecessary complexity to approval-voting and also we might still import most of
the votes unbatched, but one-by-one, depending on what point in time the dispute
was raised.</p>
<p>Instead of the dispute coordinator informing approval-voting of an ongoing
dispute for it to begin forwarding votes to the dispute coordinator, it makes
more sense for the dispute-coordinator to just ask approval-voting for votes of
candidates in dispute. This way, the dispute coordinator can also pick the best
time for maximizing the number of votes in the batch.</p>
<p>Now the question remains, when should the dispute coordinator ask
approval-voting for votes? As argued above already, querying approval votes at
the beginning of the dispute, will likely already take care of most malicious
votes. Still we would like to have a record of all, if possible. So what are
other points in time we might query approval votes?</p>
<p>In fact for slashing it is only relevant to have them once the dispute
concluded, so we can query approval voting the moment the dispute concludes!
There are two potential caveats with this though:</p>
<ol>
<li>
<p>Timing: We would like to rely as little as possible on implementation details
of approval voting. In particular, if the dispute is ongoing for a long time,
do we have any guarantees that approval votes are kept around long enough by
approval voting? Will approval votes still be present by the time the
dispute concludes in all cases? The answer is nuanced, but in general we
cannot rely on it. The problem is first, that finalization and
approval-voting is an off-chain process so there is no global consensus: As
soon as at least f+1 honest (f= n/3, where n is the number of
validators/nodes) nodes have seen the dispute conclude, finalization will
take place and approval votes will be cleared. This would still be fine, if
we had some guarantees that those honest nodes will be able to include those
votes in a block. This guarantee does not exist unfortunately, we will
discuss the problem and solutions in more detail [below][#Ensuring Chain Import].</p>
<p>The second problem is that approval-voting will abandon votes as soon as a
chain can no longer be finalized (some other/better fork already has been).
This second problem can somehow be mitigated by also importing votes as soon
as a dispute is detected, but not fully resolved. It is still inherently
racy. The problem can be solved in at least two ways: Either go back to full
eager import of approval votes into the dispute-coordinator in some more
efficient manner or by changing requirements on approval-voting, making it
hold on votes longer than necessary for approval-voting itself. Conceptually
both solutions are equivalent, as we make sure votes are available even
without an ongoing dispute. For now, in the interest of time we punt on this
issue: If nodes import votes as soon as a dispute is raised in addition to
when it concludes, we have a good chance of getting relevant votes and even
if not, the fundamental security properties will still hold: Backers are
getting slashed, therefore gambler's ruin is maintained. We would still like
to fix this at <a href="https://github.com/paritytech/polkadot/issues/5864">some
point</a>.</p>
</li>
<li>
<p>There could be a chicken and egg problem: If we wait for approval vote import
for the dispute to conclude, we would run into a problem if we needed those
approval votes to get enough votes to conclude the dispute. Luckily it turns
out that this is not quite true or at least can be made not true easily: As
already mentioned, approval voting and disputes are running concurrently, but
not only that, they race with each other! A node might simultaneously start
participating in a dispute via the dispute coordinator, due to learning about
a dispute via dispute-distribution, while also participating in approval
voting. By distributing our own approval vote we make sure the dispute can
conclude regardless how the race ended (we either participate explicitly
anyway or we sent our already present approval vote). By importing all
approval votes we make it possible to slash malicious approval voters, even
if they also cast an invalid explicit vote.</p>
</li>
</ol>
<p>Conclusion: As long as we make sure, if our own approval vote gets imported
(which would prevent dispute participation) to also distribute it via
dispute-distribution, disputes can conclude. To mitigate raciness with
approval-voting deleting votes we will import approval votes twice during a
dispute: Once when it is raised, to make as sure as possible to see approval
votes also for abandoned forks and second when the dispute concludes, to
maximize the amount of potentially malicious approval votes to be recorded. The
raciness obviously is not fully resolved by this, <a href="https://github.com/paritytech/polkadot/issues/5864">a
ticket</a> exists.</p>
<p>Ensuring vote import on chain is covered in the next section.</p>
<p>As already touched: Honest nodes
will likely validate twice, once in approval voting and once via
dispute-participation. Avoiding that does not really seem worthwhile though, as
disputes are for one exceptional, so a little wasted effort won't affect
everyday performance - second, even with eager importing of approval votes,
those doubled work is still present as disputes and approvals are racing. Every
time participation is faster than approval, a node would do double work.</p>
<h3 id="ensuring-chain-import"><a class="header" href="#ensuring-chain-import">Ensuring Chain Import</a></h3>
<p>While in the previous section we discussed means for nodes to ensure relevant
votes are recorded so attackers get slashed properly, it is crucial to also
discuss the actual chain import. Only if we guarantee that recorded votes will
also get imported on chain (on all potential chains really) we will succeed in
executing slashes. Again approval votes prove to be our weak spot here, but also
backing votes might get missed.</p>
<p>Dispute distribution will make sure all explicit dispute votes get distributed
among nodes which includes current block producers (current authority set) which
is an important property: If the dispute carries on across an era change, we
need to ensure that the new validator set will learn about any disputes and
their votes, so they can put that information on chain. Dispute-distribution
luckily has this property and sends votes to the current authority set always.
The issue is, for dispute-distribution, nodes send only their own explicit (or
in some cases their approval vote) in addition to some opposing vote. This
guarantees that at least some backing or approval vote will be present at the
block producer, but we don't have a 100% guarantee to have votes for all
backers, even less for approval checkers.</p>
<p>Reason for backing votes: While backing votes will be present on at least some
chain, that does not mean that any such chain is still considered for block
production in the current set - they might only exist on an already abandoned
fork. This means a block producer that just joined the set, might not have seen
any of them.</p>
<p>For approvals it is even more tricky: Approval voting together with finalization
is a completely off-chain process therefore those protocols don't care about
block production at all. Approval votes only have a guarantee of being
propagated between the nodes that are responsible for finalizing the concerned
blocks. This implies that on an era change the current authority set, will not
necessarily get informed about any approval votes for the previous era. Hence
even if all validators of the previous era successfully recorded all approval
votes in the dispute coordinator, they won't get a chance to put them on chain,
hence they won't be considered for slashing.</p>
<p>It is important to note, that the essential properties of the system still hold:
Dispute-distribution will distribute at <em>least one</em> &quot;valid&quot; vote to the current
authority set, hence at least one node will get slashed in case of outcome
&quot;invalid&quot;. Also in reality the validator set is rarely exchanged 100%, therefore
in practice some validators in the current authority set will overlap with the
ones in the previous set and will be able to record votes on chain.</p>
<p>Still, for maximum accountability we need to make sure a previous authority set
can communicate votes to the next one, regardless of any chain: This is yet to
be implemented see section &quot;Resiliency&quot; in dispute-distribution and
<a href="https://github.com/paritytech/polkadot/issues/3398">this</a> ticket.</p>
<h2 id="coordinating-actual-dispute-participation"><a class="header" href="#coordinating-actual-dispute-participation">Coordinating Actual Dispute Participation</a></h2>
<p>Once the dispute coordinator learns about a dispute, it is its responsibility to
make sure the local node participates in that dispute.</p>
<p>The dispute coordinator learns about a dispute by importing votes from either
chain scraping or from dispute-distribution. If it finds opposing votes (always
the case when coming from dispute-distribution), it records the presence of a
dispute. Then, in case it does not find any local vote for that dispute already,
it needs to trigger participation in the dispute (see previous section for
considerations when the found local vote is an approval vote).</p>
<p>Participation means, recovering availability and re-evaluating the POV. The
result of that validation (either valid or invalid) will be the node's vote on
that dispute: Either explicit &quot;invalid&quot; or &quot;valid&quot;. The dispute coordinator will
inform <code>dispute-distribution</code> about our vote and <code>dispute-distribution</code> will make
sure that our vote gets distributed to all other validators.</p>
<p>Nothing ever is that easy though. We can not blindly import anything that comes
along and trigger participation no matter what.</p>
<h3 id="spam-considerations"><a class="header" href="#spam-considerations">Spam Considerations</a></h3>
<p>In Polkadot's security model, it is important that attempts to attack the system
result in a slash of the offenders. Therefore we need to make sure that this
slash is actually happening. Attackers could try to prevent the slashing from
taking place, by overwhelming validators with disputes in such a way that no
single dispute ever concludes, because nodes are busy processing newly incoming
ones. Other attacks are imaginable as well, like raising disputes for candidates
that don't exist, just filling up everyone's disk slowly or worse making nodes
try to participate, which will result in lots of network requests for recovering
availability.</p>
<p>The last point brings up a significant consideration in general: Disputes are
about escalation: Every node will suddenly want to check, instead of only a few.
A single message will trigger the whole network to start significant amount of
work and will cause lots of network traffic and messages. Hence the
dispute system is very susceptible to being a brutal amplifier for DoS attacks,
resulting in DoS attacks to become very easy and cheap, if we are not careful.</p>
<p>One counter measure we are taking is making raising of disputes a costly thing:
If you raise a dispute, because you claim a candidate is invalid, although it is
in fact valid - you will get slashed, hence you pay for consuming those
resources. The issue is: This only works if the dispute concerns a candidate
that actually exists!</p>
<p>If a node raises a dispute for a candidate that never got included (became
available) on any chain, then the dispute can never conclude, hence nobody gets
slashed. It makes sense to point out that this is less bad than it might sound
at first, as trying to participate in a dispute for a non existing candidate is
&quot;relatively&quot; cheap. Each node will send out a few hundred tiny request messages
for availability chunks, which all will end up in a tiny response &quot;NoSuchChunk&quot;
and then no participation will actually happen as there is nothing to
participate. Malicious nodes could provide chunks, which would make things more
costly, but at the full expense of the attackers bandwidth - no amplification
here. I am bringing that up for completeness only: Triggering a thousand nodes
to send out a thousand tiny network messages by just sending out a single
garbage message, is still a significant amplification and is nothing to ignore -
this could absolutely be used to cause harm!</p>
<h4 id="participation"><a class="header" href="#participation">Participation</a></h4>
<p>As explained, just blindly participating in any &quot;dispute&quot; that comes along is
not a good idea. First we would like to make sure the dispute is actually
genuine, to prevent cheap DoS attacks. Secondly, in case of genuine disputes, we
would like to conclude one after the other, in contrast to
processing all at the same time, slowing down progress on all of them, bringing
individual processing to a complete halt in the worst case (nodes get overwhelmed
at some stage in the pipeline).</p>
<p>To ensure to only spend significant work on genuine disputes, we only trigger
participation at all on any <em>vote import</em> if any of the following holds true:</p>
<ul>
<li>We saw the disputed candidate included on at least one fork of the chain</li>
<li>We have &quot;our&quot; availability chunk available for that candidate as this suggests
that either availability was at least run, although it might not have
succeeded or we have been a backing node of the candidate. In both cases the
candidate is at least not completely made up and there has been some effort
already flown into that candidate.</li>
<li>The dispute is already confirmed: Meaning that 1/3+1 nodes already
participated, as this suggests in our threat model that there was at least one
honest node that already voted, so the dispute must be genuine.</li>
</ul>
<p>Note: A node might be out of sync with the chain and we might only learn about a
block including a candidate, after we learned about the dispute. This means, we
have to re-evaluate participation decisions on block import!</p>
<p>With this nodes won't waste significant resources on completely made up
candidates. The next step is to process dispute participation in a (globally)
ordered fashion. Meaning a majority of validators should arrive at at least
roughly at the same ordering of participation, for disputes to get resolved one
after another. This order is only relevant if there are lots of disputes, so we
obviously only need to worry about order if participations start queuing up.</p>
<p>We treat participation for candidates that we have seen included with priority
and put them on a priority queue which sorts participation based on the block
number of the relay parent of that candidate and for candidates with the same
relay parent height further by the <code>CandidateHash</code>. This ordering is globally
unique and also prioritizes older candidates.</p>
<p>The latter property makes sense, because if an older candidate turns out invalid,
we can roll back the full chain at once. If we resolved earlier disputes first
and they turned out invalid as well, we might need to roll back a couple of
times instead of just once to the oldest offender. This is obviously a good
idea, in particular it makes it impossible for an attacker to prevent rolling
back a very old candidate, by keeping raising disputes for newer candidates.</p>
<p>For candidates we have not seen included, but we have our availability piece
available we put participation on a best-effort queue, which at the moment is
processed on the basis how often we requested participation locally, which
equals the number of times we imported votes for that dispute. The idea is, if
we have not seen the candidate included, but the dispute is valid, other nodes
will have seen it included - so the more votes there are, the more likely it is
a valid dispute and we should implicitly arrive at a similar ordering as the
nodes that are able to sort based on the relay parent block height.</p>
<h4 id="import"><a class="header" href="#import">Import</a></h4>
<p>In the last section we looked at how to treat queuing participations to handle
heavy dispute load well. This already ensures, that honest nodes won't amplify
cheap DoS attacks. There is one minor issue remaining: Even if we delay
participation until we have some confirmation of the authenticity of the
dispute, we should also not blindly import all votes arriving into the
database as this might be used to just slowly fill up disk space, until the node
is no longer functional. This leads to our last protection mechanism at the
dispute coordinator level (dispute-distribution also has its own), which is spam
slots. For each import, where we don't know whether it might be spam or not we
increment a counter for each signing participant of explicit <code>invalid</code> votes.</p>
<h2>The reason this works is because we only need to worry about actual dispute
votes. Import of backing votes are already rate limited and concern only real
candidates for approval votes a similar argument holds (if they come from
approval-voting), but we also don't import them until a dispute already
concluded. For actual dispute votes, we need two opposing votes, so there must be
an explicit <code>invalid</code> vote in the import. Only a third of the validators can be
malicious, so spam disk usage is limited to <code>2*vote_size*n/3*NUM_SPAM_SLOTS</code>, with
n being the number of validators.</h2>
<p>More reasoning behind spam considerations can be found on
this sr-lab ticket: https://github.com/paritytech/srlabs_findings/issues/179</p>
<h2 id="disputes-for-non-included-candidates"><a class="header" href="#disputes-for-non-included-candidates">Disputes for Non Included Candidates</a></h2>
<p>We only ever care about disputes for candidates that have been included on at
least some chain (became available). This is because the availability system was
designed for precisely that: Only with inclusion (availability) we have
guarantees about the candidate to actually be available. Because only then we
have guarantees that malicious backers can be reliably checked and slashed. The
system was also designed for non included candidates to not pose any threat to
the system.</p>
<p>One could think of an (additional) dispute system to make it possible to dispute
any candidate that has been proposed by a validator, no matter whether it got
successfully included or even backed. Unfortunately, it would be very brittle
(no availability) and also spam protection would be way harder than for the
disputes handled by the dispute-coordinator. In fact all described spam handling
strategies above would simply be not available.</p>
<p>It is worth thinking about who could actually raise such disputes anyway:
Approval checkers certainly not, as they will only ever check once availability
succeeded. The only other nodes that meaningfully could/would are honest backing
nodes or collators. For collators spam considerations would be even worse as
there can be an unlimited number of them and we can not charge them for spam, so
trying to handle disputes raised by collators would be even more complex. For
honest backers: It actually makes more sense for them to wait until availability
is reached as well, as only then they have guarantees that other nodes will be
able to check. If they disputed before, all nodes would need to recover the data
from them, so they would be an easy DoS target.</p>
<p>In summary: The availability system was designed for raising disputes in a
meaningful and secure way after availability was reached. Trying to raise
disputes before does not meaningfully contribute to the systems security/might
even weaken it as attackers are warned before availability is reached, while at
the same time adding signficant amount of complexity. We therefore punt on such
disputes and concentrate on disputes the system was designed to handle.</p>
<h2 id="database-schema"><a class="header" href="#database-schema">Database Schema</a></h2>
<p>We use an underlying Key-Value database where we assume we have the following operations available:</p>
<ul>
<li><code>write(key, value)</code></li>
<li><code>read(key) -&gt; Option&lt;value&gt;</code></li>
<li><code>iter_with_prefix(prefix) -&gt; Iterator&lt;(key, value)&gt;</code> - gives all keys and values in
lexicographical order where the key starts with <code>prefix</code>.</li>
</ul>
<p>We use this database to encode the following schema:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(&quot;candidate-votes&quot;, SessionIndex, CandidateHash) -&gt; Option&lt;CandidateVotes&gt;
&quot;recent-disputes&quot; -&gt; RecentDisputes
&quot;earliest-session&quot; -&gt; Option&lt;SessionIndex&gt;
<span class="boring">}
</span></code></pre></pre>
<p>The meta information that we track per-candidate is defined as the <code>CandidateVotes</code> struct.
This draws on the <a href="../../types/disputes.html">dispute statement types</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Tracked votes on candidates, for the purposes of dispute resolution.
pub struct CandidateVotes {
  /// The receipt of the candidate itself.
  pub candidate_receipt: CandidateReceipt,
  /// Votes of validity, sorted by validator index.
  pub valid: Vec&lt;(ValidDisputeStatementKind, ValidatorIndex, ValidatorSignature)&gt;,
  /// Votes of invalidity, sorted by validator index.
  pub invalid: Vec&lt;(InvalidDisputeStatementKind, ValidatorIndex, ValidatorSignature)&gt;,
}

/// The mapping for recent disputes; any which have not yet been pruned for being ancient.
pub type RecentDisputes = std::collections::BTreeMap&lt;(SessionIndex, CandidateHash), DisputeStatus&gt;;

/// The status of dispute. This is a state machine which can be altered by the
/// helper methods.
pub enum DisputeStatus {
  /// The dispute is active and unconcluded.
  Active,
  /// The dispute has been concluded in favor of the candidate
  /// since the given timestamp.
  ConcludedFor(Timestamp),
  /// The dispute has been concluded against the candidate
  /// since the given timestamp.
  ///
  /// This takes precedence over `ConcludedFor` in the case that
  /// both are true, which is impossible unless a large amount of
  /// validators are participating on both sides.
  ConcludedAgainst(Timestamp),
  /// Dispute has been confirmed (more than `byzantine_threshold` have already participated/ or
  /// we have seen the candidate included already/participated successfully ourselves).
  Confirmed,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="protocol"><a class="header" href="#protocol">Protocol</a></h2>
<p>Input: <a href="../../types/overseer-protocol.html#dispute-coordinator-message"><code>DisputeCoordinatorMessage</code></a></p>
<p>Output:</p>
<ul>
<li><a href="../../types/overseer-protocol.html#runtime-api-message"><code>RuntimeApiMessage</code></a></li>
</ul>
<h2 id="functionality"><a class="header" href="#functionality">Functionality</a></h2>
<p>This assumes a constant <code>DISPUTE_WINDOW: SessionWindowSize</code>. This should correspond to at least 1
day.</p>
<p>Ephemeral in-memory state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct State {
  keystore: Arc&lt;LocalKeystore&gt;,
  rolling_session_window: RollingSessionWindow,
  highest_session: SessionIndex,
  spam_slots: SpamSlots,
  participation: Participation,
  ordering_provider: OrderingProvider,
  participation_receiver: WorkerMessageReceiver,
  metrics: Metrics,
  // This tracks only rolling session window failures.
  // It can be a `Vec` if the need to track more arises.
  error: Option&lt;SessionsUnavailable&gt;,
  /// Latest relay blocks that have been successfully scraped.
  last_scraped_blocks: LruCache&lt;Hash, ()&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="on-startup"><a class="header" href="#on-startup">On startup</a></h3>
<p>When the subsystem is initialised it waits for a new leaf (message <code>OverseerSignal::ActiveLeaves</code>).
The leaf is used to initialise a <code>RollingSessionWindow</code> instance (contains leaf hash and
<code>DISPUTE_WINDOW</code> which is a constant.</p>
<p>Next the active disputes are loaded from the DB. The subsystem checks if there are disputes for
which a local statement is not issued. A list of these is passed to the main loop.</p>
<h3 id="the-main-loop"><a class="header" href="#the-main-loop">The main loop</a></h3>
<p>Just after the subsystem initialisation the main loop (<code>fn run_until_error()</code>) runs until
<code>OverseerSignal::Conclude</code> signal is received. Before executing the actual main loop the leaf and
the participations, obtained during startup are enqueued for processing. If there is capacity (the
number of running participations is less than <code>MAX_PARALLEL_PARTICIPATIONS</code>) participation jobs are
started (<code>func participate</code>). Finally the component waits for messages from Overseer. The behaviour
on each message is described in the following subsections.</p>
<h3 id="on-overseersignalactiveleaves"><a class="header" href="#on-overseersignalactiveleaves">On <code>OverseerSignal::ActiveLeaves</code></a></h3>
<p>Initiates processing via the <code>Participation</code> module and updates the internal state of the subsystem.
More concretely:</p>
<ul>
<li>Passes the <code>ActiveLeavesUpdate</code> message to the ordering provider.</li>
<li>Updates the session info cache.</li>
<li>Updates <code>self.highest_session</code>.</li>
<li>Prunes old spam slots in case the session window has advanced.</li>
<li>Scrapes on chain votes.</li>
</ul>
<h3 id="on-muxedmessageparticipation"><a class="header" href="#on-muxedmessageparticipation">On <code>MuxedMessage::Participation</code></a></h3>
<p>This message is sent from <code>Participatuion</code> module and indicates a processed dispute participation.
It's the result of the processing job initiated with <code>OverseerSignal::ActiveLeaves</code>. The subsystem
issues a <code>DisputeMessage</code> with the result.</p>
<h3 id="on-overseersignalconclude"><a class="header" href="#on-overseersignalconclude">On <code>OverseerSignal::Conclude</code></a></h3>
<p>Exit gracefully.</p>
<h3 id="on-overseersignalblockfinalized"><a class="header" href="#on-overseersignalblockfinalized">On <code>OverseerSignal::BlockFinalized</code></a></h3>
<p>Performs cleanup of the finalized candidate.</p>
<h3 id="on-disputecoordinatormessageimportstatements"><a class="header" href="#on-disputecoordinatormessageimportstatements">On <code>DisputeCoordinatorMessage::ImportStatements</code></a></h3>
<p>Import statements by validators are processed in <code>fn handle_import_statements()</code>. The function has
got three main responsibilities:</p>
<ul>
<li>Initiate participation in disputes and sending out of any existing own
approval vote in case of a raised dispute.</li>
<li>Persist all fresh votes in the database. Fresh votes in this context means votes that are not
already processed by the node.</li>
<li>Spam protection on all invalid (<code>DisputeStatement::Invalid</code>) votes. Please check the SpamSlots
section for details on how spam protection works.</li>
</ul>
<h3 id="on-disputecoordinatormessagerecentdisputes"><a class="header" href="#on-disputecoordinatormessagerecentdisputes">On <code>DisputeCoordinatorMessage::RecentDisputes</code></a></h3>
<p>Returns all recent disputes saved in the DB.</p>
<h3 id="on-disputecoordinatormessageactivedisputes"><a class="header" href="#on-disputecoordinatormessageactivedisputes">On <code>DisputeCoordinatorMessage::ActiveDisputes</code></a></h3>
<p>Returns all recent disputes concluded within the last <code>ACTIVE_DURATION_SECS</code> .</p>
<h3 id="on-disputecoordinatormessagequerycandidatevotes"><a class="header" href="#on-disputecoordinatormessagequerycandidatevotes">On <code>DisputeCoordinatorMessage::QueryCandidateVotes</code></a></h3>
<p>Loads <code>candidate-votes</code> for every <code>(SessionIndex, CandidateHash)</code> in the input query and returns
data within each <code>CandidateVote</code>. If a particular <code>candidate-vote</code> is missing, that particular
request is omitted from the response.</p>
<h3 id="on-disputecoordinatormessageissuelocalstatement"><a class="header" href="#on-disputecoordinatormessageissuelocalstatement">On <code>DisputeCoordinatorMessage::IssueLocalStatement</code></a></h3>
<p>Executes <code>fn issue_local_statement()</code> which performs the following operations:</p>
<ul>
<li>Deconstruct into parts <code>{ session_index, candidate_hash, candidate_receipt, is_valid }</code>.</li>
<li>Construct a <a href="../../types/disputes.html#disputestatement"><code>DisputeStatement</code></a> based on <code>Valid</code> or <code>Invalid</code>, depending on the
parameterization of this routine.</li>
<li>Sign the statement with each key in the <code>SessionInfo</code>'s list of parachain validation keys which is
present in the keystore, except those whose indices appear in <code>voted_indices</code>. This will typically
just be one key, but this does provide some future-proofing for situations where the same node may
run on behalf multiple validators. At the time of writing, this is not a use-case we support as
other subsystems do not invariably   provide this guarantee.</li>
<li>Write statement to DB.</li>
<li>Send a <code>DisputeDistributionMessage::SendDispute</code> message to get the vote distributed to other
validators.</li>
</ul>
<h3 id="on-disputecoordinatormessagedetermineundisputedchain"><a class="header" href="#on-disputecoordinatormessagedetermineundisputedchain">On <code>DisputeCoordinatorMessage::DetermineUndisputedChain</code></a></h3>
<p>Executes <code>fn determine_undisputed_chain()</code> which performs the following:</p>
<ul>
<li>Load <code>&quot;recent-disputes&quot;</code>.</li>
<li>Deconstruct into parts <code>{ base_number, block_descriptions, rx }</code></li>
<li>Starting from the beginning of <code>block_descriptions</code>:
<ol>
<li>Check the <code>RecentDisputes</code> for a dispute of each candidate in the block description.</li>
<li>If there is a dispute which is active or concluded negative, exit the loop.</li>
</ol>
</li>
<li>For the highest index <code>i</code> reached in the <code>block_descriptions</code>, send <code>(base_number + i + 1, block_hash)</code> on the channel, unless <code>i</code> is 0, in which case <code>None</code> should be sent. The
<code>block_hash</code> is determined by inspecting <code>block_descriptions[i]</code>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../node/disputes/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../node/disputes/dispute-distribution.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../node/disputes/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../node/disputes/dispute-distribution.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../../mermaid.min.js"></script>
        <script type="text/javascript" src="../../mermaid-init.js"></script>


    </body>
</html>
